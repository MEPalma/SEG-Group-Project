package DatabaseManager;

import Commons.*;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.NumberFormat;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * Created by Marco-Edoardo Palma.
 */

/*
 * This class will process queries from QueryComposer.java into DatabaseManager.
 * The 'interface' between frontend and backend
 */
public class DataExchange {

    private DatabaseManager dbM;

    public DataExchange(DatabaseManager databaseManager) {
        this.dbM = databaseManager;
    }

    /**
     * formats the price according to the UK currency.
     *
     * @param price
     * @return
     */
    public static String formatPrice(double price) {
        NumberFormat priceNumberFormat = NumberFormat.getCurrencyInstance(Locale.UK);
        return priceNumberFormat.format(price);
    }

    /**
     * formats the percentage to 2dp
     *
     * @param percentage
     * @return
     */
    public static String formatPercentage(double percentage) {
        NumberFormat numberFormat = NumberFormat.getPercentInstance();
        numberFormat.setMaximumFractionDigits(2);
        numberFormat.setMinimumFractionDigits(2);
        return numberFormat.format(percentage / 100);
    }

    /**
     * closes the ResultSet of a query. this should be called at the end of
     * every parsing routine.
     *
     * @param resultSet
     */
    public static void close(ResultSet resultSet) {
        try {
            resultSet.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * closes the connection of the database. Do this only before exiting the
     * application!
     */
    public void close() {
        this.dbM.close();
    }

    /**
     * Executes the batch of a Statement, then closes the Statement.
     *
     * @param s
     * @throws SQLException
     */
    public void writeSqlStatement(Statement s) throws SQLException {
        s.executeBatch();
        s.close();
    }

    /**
     * Returns a statement generated by the Database connection.
     *
     * @return
     * @throws SQLException
     */
    public Statement getSqlStatement() throws SQLException {
        return this.dbM.getDbCon().createStatement();
    }

    /**
     * turns on and off the pragma on foreign keys. This might speed up the
     * insertion process of multiple insert statements. it is important for this
     * to be turned on after the insertion was carried out, in order to ensure
     * the integrity of the data in the database.
     *
     * @param b
     */
    public void setForiegnKeyPragma(boolean b) {
        if (b) {
            this.dbM.writeQuery("PRAGMA foreign_keys = ON;");
        } else {
            this.dbM.writeQuery("PRAGMA foreign_keys = OFF;");
        }
    }

    /**
     * Enables and disables the auto commit function of the connection with the
     * database. When off, no commits will be performed until the commit
     * function is called. Useful when inserting large amount of data, is should
     * be turned on whenever possible.
     *
     * @param b
     * @throws SQLException
     */
    public void setAutoCommit(boolean b) throws SQLException {
        this.dbM.getDbCon().setAutoCommit(b);
    }

    /**
     * Commits immediately pending statements on the database connection.
     *
     * @throws SQLException
     */
    public void commitNow() throws SQLException {
        this.dbM.getDbCon().commit();
    }

    /**
     * returns the last id generated by the database. This is especially useful
     * when after insert statement with a auto increment id.
     *
     * @return
     */
    private int getLastID() {
        try {
            ResultSet resultSet = this.dbM.query(QueryComposer.GETLASTID);
            int c = resultSet.getInt("id");
            close(resultSet);
            return c;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        System.exit(8);
        return -1;
    }

    public boolean isEmpty() {
        int tmp = 0;

        tmp = countAllFrom_CLICK_LOGS();
        if (tmp > 0) return false;

        tmp = countAllFrom_IMPRESSION_LOGS();
        if (tmp > 0) return false;

        tmp = countAllFrom_SERVER_LOGS();
        if (tmp > 0) return false;

        tmp = countAllFrom_USERS();
        if (tmp > 0) return false;

        return true;
    }

    /*
        PARSERS:

            SINGLE RETURNS (parse only one object from a ResultSet)
     */

    /**
     * Parses a ResultSet into a UserEntry and does not close the ResultSet.
     * returns null if a parsing error occurred.
     *
     * @param rset
     * @return
     */
    private UserEntry parseUserEntry(ResultSet rset) {
        try {
            return new UserEntry(
                    rset.getLong("id"),
                    rset.getInt("campaignId"),
                    Enums.IntToGender(rset.getInt("gender")),
                    Enums.IntToAge(rset.getInt("age")),
                    Enums.IntToIncome(rset.getInt("income")));
        } catch (SQLException ex) {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * Parses a ResultSet into a ImpressionEntry and does not close the
     * ResultSet. returns null if a parsing error occurred.
     *
     * @param rset
     * @return
     */
    private ImpressionEntry parseImpressionEntry(ResultSet rset) {
        try {
            return new ImpressionEntry(
                    rset.getInt("id"),
                    rset.getLong("userId"),
                    rset.getInt("campaignId"),
                    Stringifiable.secondsToDate(rset.getLong("date")),
                    Enums.IntToContext(rset.getInt("context")),
                    rset.getDouble("impressionCost"));
        } catch (SQLException ex) {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * Parses a ResultSet into a ClickEntry and does not close the ResultSet.
     * returns null if a parsing error occurred.
     *
     * @param rset
     * @return
     */
    private ClickEntry parseClickEntry(ResultSet rset) {
        try {
            return new ClickEntry(
                    rset.getInt("id"),
                    rset.getString("userId"),
                    rset.getInt("campaignId"),
                    Stringifiable.secondsToDate(rset.getLong("date")),
                    rset.getDouble("clickCost"));
        } catch (SQLException ex) {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * Parses a ResultSet into a ServerEntry and does not close the ResultSet.
     * returns null if a parsing error occurred.
     *
     * @param rset
     * @return
     */
    private ServerEntry parseServerEntry(ResultSet rset) {
        try {
            return new ServerEntry(
                    rset.getInt("id"),
                    rset.getLong("userId"),
                    rset.getInt("campaignId"),
                    Stringifiable.secondsToDate(rset.getLong("entryDate")),
                    Stringifiable.secondsToDate(rset.getLong("exitDate")),
                    rset.getInt("pagesViewed"),
                    Enums.Conversion.valueOf(rset.getString("conversion")));
        } catch (SQLException ex) {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /*
            MULTIPLE RETURNS (parse a list of objects from a ResultSet)
     */

    /**
     * Parses a result set into a list of UserEntrys, returns an empty list if a
     * parsing error occurred. It does not close the ResultSet.
     *
     * @param rset
     * @return
     */
    private List<UserEntry> parseUserEntrys(ResultSet rset) {
        try {
            List<UserEntry> users = new LinkedList<UserEntry>();
            while (rset.next()) {
                users.add(parseUserEntry(rset));
            }

            return users;
        } catch (Exception e) {
            e.printStackTrace();
            return new LinkedList<UserEntry>();
        }
    }

    /**
     * Parses a result set into a list of ImpressionEntry, returns an empty list
     * if a parsing error occurred. It does not close the ResultSet.
     *
     * @param rset
     * @return
     */
    private List<ImpressionEntry> parseImpressionEntrys(ResultSet rset) {
        try {
            List<ImpressionEntry> impressions = new LinkedList<ImpressionEntry>();
            while (rset.next()) {
                impressions.add(parseImpressionEntry(rset));
            }

            return impressions;
        } catch (Exception e) {
            e.printStackTrace();
            return new LinkedList<ImpressionEntry>();
        }
    }

    /**
     * Parses a result set into a list of ClickEntry, returns an empty list if a
     * parsing error occurred. It does not close the ResultSet.
     *
     * @param rset
     * @return
     */
    private List<ClickEntry> parseClickEntrys(ResultSet rset) {
        try {
            List<ClickEntry> clicks = new LinkedList<ClickEntry>();
            while (rset.next()) {
                clicks.add(parseClickEntry(rset));
            }

            return clicks;
        } catch (SQLException e) {
            return new LinkedList<ClickEntry>();
        }
    }

    /**
     * Parses a result set into a list of ServerEntry, returns an empty list if
     * a parsing error occurred. It does not close the ResultSet.
     *
     * @param rset
     * @return
     */
    private List<ServerEntry> parseServerEntrys(ResultSet rset) {
        try {
            List<ServerEntry> servers = new LinkedList<ServerEntry>();
            while (rset.next()) {
                servers.add(parseServerEntry(rset));
            }

            return servers;
        } catch (Exception e) {
            e.printStackTrace();
            return new LinkedList<ServerEntry>();
        }
    }

    /**
     * Parses a result set into a map of settings in the form name -> value,
     * returns an empty map if a parsing error occurred. It does not close the
     * ResultSet.
     *
     * @param rset
     * @return
     */
    private Map<String, String> parseSettings(ResultSet rset) {
        try {
            Map<String, String> settings = new HashMap<String, String>();
            while (rset.next()) {
                settings.put(rset.getString("name"), rset.getString("value"));
            }

            return settings;
        } catch (Exception e) {
            e.printStackTrace();
            return new HashMap<String, String>();
        }
    }

    /*
        INSERT STATEMENTS
     */
    public void insertUserStmt(UserEntry user) {
        this.dbM.writeQuery(QueryComposer.insertUserStmt(user));
    }

    public void insertImpressionStmt(ImpressionEntry ie) {
        this.dbM.writeQuery(QueryComposer.insertImpressionStmt(ie));
        ie.setId(this.getLastID());
    }

    public void insertClickStmt(ClickEntry ce) {
        this.dbM.writeQuery(QueryComposer.insertClickStmt(ce));
        ce.setId(this.getLastID());
    }

    public void insertServerStmt(ServerEntry se) {
        this.dbM.writeQuery(QueryComposer.insertServerStmt(se));
        se.setId(this.getLastID());
    }

    public void insertSettingStmt(String name, String value) {
        this.dbM.writeQuery(QueryComposer.insertSettingStmt(name, value));
    }

    /*
        UPDATE STATEMENTS
     */
    // if you need them call me up (Marco)
    /*
        DELETE STATEMENTS
     */
    // if you need them call me up (Marco)
    /*
        DROP ALL STATEMENTS
     */
    public void dropAllFrom_USERS() {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_USERS);
    }

    public void dropAllFrom_IMPRESSION_LOGS() {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_IMPRESSION_LOGS);
    }

    public void dropAllFrom_CLICK_LOGS() {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_CLICK_LOGS);
    }

    public void dropAllFrom_SERVER_LOGS() {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_SERVER_LOGS);
    }

    public void dropAllFrom_SETTINGS() {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_SETTINGS);
    }

    public void dropAll_noSettings() {
        this.dbM.writeQuery(QueryComposer.dropAll_noSettings);
    }

    /*
        COUNT STATEMENTS
     */

    private int parseCountQuery(ResultSet resultSet) {
        try {
            int tmp = resultSet.getInt("c");
            close(resultSet);
            return tmp;
        } catch (SQLException e) {
            e.printStackTrace();
            return 0;
        }
    }

    public int countAllFrom_USERS() {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_USERS));
    }

    public int countAllFrom_IMPRESSION_LOGS() {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_IMPRESSION_LOGS));
    }

    public int countAllFrom_CLICK_LOGS() {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_CLICK_LOGS));
    }

    public int countAllFrom_SERVER_LOGS() {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_SERVER_LOGS));
    }

    public int countAllFrom_SETTINGS() {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_SETTINGS));
    }

    /*
        SELECT ALL STATEMENTS
     */
    public List<UserEntry> selectAllFrom_USERS() {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_USERS);
        List tmp = parseUserEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ImpressionEntry> selectAllFrom_IMPRESSION_LOGS() {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_IMPRESSION_LOGS);
        List tmp = parseImpressionEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ClickEntry> selectAllFrom_CLICK_LOGS() {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_CLICK_LOGS);
        List tmp = parseClickEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ServerEntry> selectAllFrom_SERVER_LOGS() {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_SERVER_LOGS);
        List tmp = parseServerEntrys(rset);
        close(rset);
        return tmp;
    }

    public Map<String, String> selectAllFrom_SETTINGS() {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_SETTINGS);
        Map tmp = parseSettings(rset);
        close(rset);
        return tmp;
    }

    /*
        SELECT BY ID
     */
    public UserEntry selectByIdFrom_USERS(String id) {
        ResultSet rset = this.dbM.query(QueryComposer.selectByIdFrom_USERS(id));

        UserEntry tmp = (UserEntry) this.parseUserEntry(rset);

        close(rset);
        return tmp;
    }

    public ImpressionEntry selectByIdFrom_IMPRESSION_LOGS(int id) {
        ResultSet rset = this.dbM.query(QueryComposer.selectByIdFrom_IMPRESSION_LOGS(id));

        ImpressionEntry tmp = (ImpressionEntry) this.parseImpressionEntry(rset);

        close(rset);
        return tmp;
    }

    public ClickEntry selectByIdFrom_CLICK_LOGS(int id) {
        ResultSet rset = this.dbM.query(QueryComposer.selectByIdFrom_CLICK_LOGS(id));

        ClickEntry tmp = (ClickEntry) this.parseClickEntry(rset);

        close(rset);
        return tmp;
    }

    public ServerEntry selectByIdFrom_SERVER_LOGS(int id) {
        ResultSet rset = this.dbM.query(QueryComposer.selectByIdFrom_SERVER_LOGS(id));

        ServerEntry tmp = (ServerEntry) this.parseServerEntry(rset);

        close(rset);
        return tmp;
    }

    /*
        SELECT BY userId
     */
    public List<ImpressionEntry> selectByUserIdFrom_IMPRESSION_LOGS(String userId) {
        ResultSet rset = this.dbM.query(QueryComposer.selectByUserIdFrom_IMPRESSION_LOGS(userId));
        List tmp = parseImpressionEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ClickEntry> selectByUserIdFrom_CLICK_LOGS(String userId) {
        ResultSet rset = this.dbM.query(QueryComposer.selectByUserIdFrom_CLICK_LOGS(userId));
        List tmp = parseClickEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ServerEntry> selectByUserIdFrom_SERVER_LOGS(String userId) {
        ResultSet rset = this.dbM.query(QueryComposer.selectByUserIdFrom_SERVER_LOGS(userId));
        List tmp = parseServerEntrys(rset);
        close(rset);
        return tmp;
    }

    public String selectByNameFrom_SETTINGS(String name) {
        ResultSet resultSet = this.dbM.query(QueryComposer.selectByNameFrom_SETTINGS(name));
        try {
            return resultSet.getString("value");
        } catch (SQLException ex) {
            return null;
        }
    }


    /*
        CAMPAIGNS
     */
    public List<Tuple<Integer, String>> selectAllCampaigns() {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllCampaigns);

        List<Tuple<Integer, String>> names = new LinkedList();

        try {
            while (rset.next())
                names.add(new Tuple(rset.getInt(1), rset.getString(2)));

        } catch (SQLException e) {

        }

        return names;
    }

    public int insertNewCampaign(String name) {
        this.dbM.writeQuery(QueryComposer.insertNewCampaign(name));
        return getLastID();
    }

    public void setCampaignName(int id, String name) {
        this.dbM.writeQuery(QueryComposer.updateCampaignName(id, name));
    }

    public String getCampaignName(int id) {
        ResultSet resultSet = this.dbM.query(QueryComposer.getCampaignName(id));
        try {
            return resultSet.getString("v");
        } catch (SQLException ex) {
            setCampaignName(id, "Unknown");
            return getCampaignName(id);
        }
    }

    public void setColorSeries(int id) {
        this.dbM.writeQuery(QueryComposer.setColorSeries(id));
    }

    public int getColorSeries() {
        ResultSet resultSet = this.dbM.query(QueryComposer.getColorSeries);
        try {
            return resultSet.getInt("v");
        } catch (SQLException ex) {
            setColorSeries(1);
            return getColorSeries();
        }
    }

    public List<Tuple<String, Number>> getGraphData(GraphSpecs graphSpecs) {
        try {

            if (graphSpecs.getMetric() == GraphSpecs.METRICS.CTR) {

                ResultSet leftSet = this.dbM.query(QueryComposer.composeQuery(new GraphSpecs (
                                                                                    graphSpecs.getCampaignId(),
                                                                                    GraphSpecs.METRICS.NumberClicks,
                                                                                    graphSpecs.getTimespan(),
                                                                                    graphSpecs.getBounceDef(),
                                                                                    graphSpecs.getFilterSpecs())));
                ResultSet rightSet = this.dbM.query(QueryComposer.composeQuery(new GraphSpecs(
                                                                                    graphSpecs.getCampaignId(),
                                                                                    GraphSpecs.METRICS.NumberImpressions,
                                                                                    graphSpecs.getTimespan(),
                                                                                    graphSpecs.getBounceDef(),
                                                                                    graphSpecs.getFilterSpecs())));
                //getInfoTupleDivision(leftSet, rightSet);
                List<Tuple<String, Number>> result = getInfoTupleDivision(leftSet, rightSet);
                close(leftSet);
                close(rightSet);
                return result;
                //getCTRPerHour();
            } else if (graphSpecs.getMetric() == GraphSpecs.METRICS.CPA) {
                ResultSet sumLeft = this.dbM.query(QueryComposer.composeSum(new GraphSpecs(
                                                                                    graphSpecs.getCampaignId(),
                                                                                    GraphSpecs.METRICS.ClickCost,
                                                                                    graphSpecs.getTimespan(),
                                                                                    graphSpecs.getBounceDef(),
                                                                                    graphSpecs.getFilterSpecs())).get(0));
                ResultSet sumRigth = this.dbM.query(QueryComposer.composeSum(new GraphSpecs(
                                                                                    graphSpecs.getCampaignId(),
                                                                                    GraphSpecs.METRICS.ImpressionCost,
                                                                                    graphSpecs.getTimespan(),
                                                                                    graphSpecs.getBounceDef(),
                                                                                    graphSpecs.getFilterSpecs())).get(1));
                List<Tuple<String, Number>> resultSum = getSum(sumLeft, sumRigth);

                ResultSet rightSet = this.dbM.query(QueryComposer.composeQuery(new GraphSpecs(
                                                                                    graphSpecs.getCampaignId(),
                                                                                    GraphSpecs.METRICS.NumberConversions,
                                                                                    graphSpecs.getTimespan(),
                                                                                    graphSpecs.getBounceDef(),
                                                                                    graphSpecs.getFilterSpecs())));

                List<Tuple<String, Number>> result = createResultDivision(resultSum, rightSet);
                close(rightSet);
                return result;
            } else if (graphSpecs.getMetric() == GraphSpecs.METRICS.CPC) {
                ResultSet sumLeft = this.dbM.query(QueryComposer.composeSum(new GraphSpecs(
                                                                                graphSpecs.getCampaignId(),
                                                                                GraphSpecs.METRICS.ClickCost,
                                                                                graphSpecs.getTimespan(),
                                                                                graphSpecs.getBounceDef(),
                                                                                graphSpecs.getFilterSpecs())).get(0));
                ResultSet sumRigth = this.dbM.query(QueryComposer.composeSum(new GraphSpecs(
                                                                                graphSpecs.getCampaignId(),
                                                                                GraphSpecs.METRICS.ImpressionCost,
                                                                                graphSpecs.getTimespan(),
                                                                                graphSpecs.getBounceDef(),
                                                                                graphSpecs.getFilterSpecs())).get(1));
                List<Tuple<String, Number>> resultSum = getSum(sumLeft, sumRigth);
                ResultSet rightSet = this.dbM.query(QueryComposer.composeQuery(new GraphSpecs(
                                                                                graphSpecs.getCampaignId(),
                                                                                GraphSpecs.METRICS.NumberClicks,
                                                                                graphSpecs.getTimespan(),
                                                                                graphSpecs.getBounceDef(),
                                                                                graphSpecs.getFilterSpecs())));
                List<Tuple<String, Number>> result = createResultDivision(resultSum, rightSet);
                close(rightSet);
                return result;
            } else if (graphSpecs.getMetric() == GraphSpecs.METRICS.CPM) {
                ResultSet sumLeft = this.dbM.query(QueryComposer.composeSum(new GraphSpecs(
                                                                                graphSpecs.getCampaignId(),
                                                                                GraphSpecs.METRICS.ClickCost,
                                                                                graphSpecs.getTimespan(),
                                                                                graphSpecs.getBounceDef(),
                                                                                graphSpecs.getFilterSpecs())).get(0));
                ResultSet sumRigth = this.dbM.query(QueryComposer.composeSum(new GraphSpecs(
                                                                                graphSpecs.getCampaignId(),
                                                                                GraphSpecs.METRICS.ImpressionCost,
                                                                                graphSpecs.getTimespan(),
                                                                                graphSpecs.getBounceDef(),
                                                                                graphSpecs.getFilterSpecs())).get(1));
                List<Tuple<String, Number>> resultSum = getSum(sumLeft, sumRigth);
                ResultSet rightSet = this.dbM.query(QueryComposer.composeQuery(new GraphSpecs(
                                                                                graphSpecs.getCampaignId(),
                                                                                GraphSpecs.METRICS.NumberImpressions,
                                                                                graphSpecs.getTimespan(),
                                                                                graphSpecs.getBounceDef(),
                                                                                graphSpecs.getFilterSpecs())));
                List<Tuple<String, Number>> result = createResultDivision(resultSum, rightSet);
                close(rightSet);
                return result;
            } else if (graphSpecs.getMetric() == GraphSpecs.METRICS.BounceRate) {
                ResultSet leftSet = this.dbM.query(QueryComposer.getNumberOfBounces(graphSpecs));
                ResultSet rightSet = this.dbM.query(QueryComposer.composeQuery(new GraphSpecs(
                                                                                graphSpecs.getCampaignId(),
                                                                                GraphSpecs.METRICS.NumberClicks,
                                                                                graphSpecs.getTimespan(),
                                                                                graphSpecs.getBounceDef(),
                                                                                graphSpecs.getFilterSpecs())));
                List<Tuple<String, Number>> result = getInfoTupleDivision(leftSet, rightSet);
                close(leftSet);
                close(rightSet);
                return result;
            } else if (graphSpecs.getMetric() == GraphSpecs.METRICS.TotalCost) {
                ResultSet leftSet = this.dbM.query(QueryComposer.composeSum(new GraphSpecs(
                        graphSpecs.getCampaignId(),
                        GraphSpecs.METRICS.ClickCost,
                        graphSpecs.getTimespan(),
                        graphSpecs.getBounceDef(),
                        graphSpecs.getFilterSpecs())).get(0));
                ResultSet rightSet = this.dbM.query(QueryComposer.composeSum(new GraphSpecs(
                                                                                graphSpecs.getCampaignId(),
                                                                                GraphSpecs.METRICS.ImpressionCost,
                                                                                graphSpecs.getTimespan(),
                                                                                graphSpecs.getBounceDef(),
                                                                                graphSpecs.getFilterSpecs())).get(1));
                List<Tuple<String, Number>> result = getSum(leftSet, rightSet);
                close(leftSet);
                close(rightSet);
                return result;
            } else {
                ResultSet resultSet = this.dbM.query(QueryComposer.composeQuery(graphSpecs));
                List tmp = getInfoTuple(resultSet);
                close(resultSet);
                return tmp;
            }
        } catch (Exception ex) {
            return new LinkedList<>();
        }
        //return new LinkedList<>();
    }

    /*
    Method that avoids duplicates for lists;
     */
    private List<Number> getNumbersInfo(ResultSet resultSetC) {
        try {
            List<Number> numberC = new LinkedList<>();
            while (resultSetC.next()) {
                numberC.add(resultSetC.getDouble("GroupedValues"));
            }

            return numberC;
        } catch (SQLException ex) {
            return null;
        }
    }

    /*
    Method that avoids duplicates for ints
     */
    private Integer getIntegerInfo(ResultSet resultInts) {
        int unique = 0;
        try {
            unique = resultInts.getInt("GroupedValues");
            return unique;
        } catch (SQLException ex) {
            return unique;
        }
    }

    private Double getDoubleInfo(ResultSet resultInts) {
        double unique = 0;
        try {
            unique = resultInts.getInt("GroupedValues");

            return unique;
        } catch (SQLException ex) {
            return null;
        }
    }

    private List<Tuple<String, Number>> createResultDivision(List<Tuple<String, Number>> list, ResultSet resultSet) {
        List<Tuple<String, Number>> root1 = new LinkedList<>();
        List<Tuple<String, Number>> result = new LinkedList<>();

        try {
            while (resultSet.next()) {

                root1.add(new Tuple<String, Number>(Stringifiable.secondsToDate(resultSet.getLong("d")).toString(), (resultSet.getFloat("c"))));

            }
            //return
            for (int i = 0; i < root1.size(); i++) {

                result.add(new Tuple<>(root1.get(i).getX(), (root1.get(i).getY().floatValue() + list.get(i).getY().floatValue())));
            }

            return result;


            //return <>
        } catch (SQLException ex) {

        }
        return new LinkedList<>();

    }

    private List<Tuple<String, Number>> getInfoTuple(ResultSet resultTuple) {
        List<Tuple<String, Number>> root = new LinkedList<>();

        try {

            while (resultTuple.next()) {
                root.add(new Tuple<String, Number>(Stringifiable.secondsToString(resultTuple.getLong("d")), (resultTuple.getFloat("c"))));
            }

            return root;
        } catch (SQLException ex) {
        }
        return new LinkedList<>();
    }

    private List<Tuple<String, Number>> getInfoTupleDivision(ResultSet resultTuple1, ResultSet resultTuple2) {
        List<Tuple<String, Number>> root1 = new LinkedList<>();
        List<Tuple<String, Number>> root2 = new LinkedList<>();
        List<Tuple<String, Number>> result = new LinkedList<>();

        try {
            while (resultTuple1.next()) {

                root1.add(new Tuple<String, Number>(Stringifiable.secondsToString(resultTuple1.getLong("d")), (resultTuple1.getFloat("c"))));

            }
            while (resultTuple2.next()) {

                root2.add(new Tuple<>(Stringifiable.secondsToString(resultTuple2.getLong("d")), (resultTuple2.getFloat("c"))));
            }

            //return
            for (int i = 0; i < root2.size(); i++) {

                result.add(new Tuple<>(root1.get(i).getX(), (root1.get(i).getY().floatValue() / root2.get(i).getY().floatValue())));
            }

            return result;


            //return <>
        } catch (SQLException ex) {

        }
        return new LinkedList<>();

    }

    private List<Tuple<String, Number>> getSum(ResultSet resultSet1, ResultSet resultSet2) {
        List<Tuple<String, Number>> root1 = new LinkedList<>();
        List<Tuple<String, Number>> root2 = new LinkedList<>();
        List<Tuple<String, Number>> result = new LinkedList<>();

        try {

            while (resultSet1.next()) {
                root1.add(new Tuple<String, Number>(Stringifiable.secondsToString(resultSet1.getLong("d")), (resultSet1.getFloat("c"))));

            }
            while (resultSet2.next()) {
                root2.add(new Tuple<>(Stringifiable.secondsToString(resultSet2.getLong("d")), (resultSet2.getFloat("c"))));
            }

            //return
            for (int i = 0; i < root2.size(); i++) {

                result.add(new Tuple<>(root1.get(i).getX(), (root1.get(i).getY().floatValue() + root2.get(i).getY().floatValue())));
            }
            return result;

            //return <>
        } catch (SQLException ex) {

        }
        return new LinkedList<>();

    }


    private List<Tuple<String, Number>> getInfoTupleDivisionCTRHOUR(ResultSet resultTuple1, ResultSet resultTuple2) {
        List<Tuple<String, Number>> root1 = new LinkedList<>();
        List<Tuple<String, Number>> root2 = new LinkedList<>();
        List<Tuple<String, Number>> result = new LinkedList<>();

        List<Date> hour = new LinkedList<>();

        List<Number> number = new LinkedList<>();
        try {

            while (resultTuple1.next()) {
                root1.add(new Tuple<String, Number>(Stringifiable.secondsToString(resultTuple1.getLong("d")), (resultTuple1.getFloat("c"))));

            }
            while (resultTuple2.next()) {
                root2.add(new Tuple<>(Stringifiable.secondsToString(resultTuple2.getLong("d")), (resultTuple2.getFloat("c"))));
            }

            //return
            for (int i = 0; i < root2.size() - 1; i++) {

                result.add(new Tuple<>(root1.get(i).getX(), (root1.get(i).getY().floatValue() / root2.get(i).getY().floatValue())));
            }
            return result;

            //return <>
        } catch (SQLException ex) {

        }
        return new LinkedList<>();

    }


    /*
    FOR TOTAL CPM--DIVIDE BY 1000
     */
    private List<Tuple<String, Number>> getInfoTupleDivisionCPM(ResultSet resultTuple1, ResultSet resultTuple2) {
        List<Tuple<String, Number>> root1 = new LinkedList<>();
        List<Tuple<String, Number>> root2 = new LinkedList<>();
        List<Tuple<String, Number>> result = new LinkedList<>();

        try {

            while (resultTuple1.next()) {
                root1.add(new Tuple<String, Number>(Stringifiable.secondsToString(resultTuple1.getLong("d")), (resultTuple1.getFloat("c"))));

            }
            while (resultTuple2.next()) {
                root2.add(new Tuple<>(Stringifiable.secondsToString(resultTuple2.getLong("d")), (resultTuple2.getFloat("c") / 1000)));
            }
            for (int i = 0; i < root2.size(); i++) {
                result.add(new Tuple<>(root1.get(i).getX(), (root1.get(i).getY().floatValue() / root2.get(i).getY().floatValue())));
            }
            return result;

            //return <>
        } catch (SQLException ex) {

        }
        return new LinkedList<>();
    }
    
    private Number getNumberFirstColumnAndClose(ResultSet rset) {
        double tmp = 0;
        
        try {
            tmp = rset.getDouble(1);
        } catch (SQLException ex) {}
        
        close(rset);
        return tmp;
    }
    
    public int getNumberOfImpressions() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getNumberOfImpressions)).intValue();
    }
    
    public int getNumberOfClicks() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getNumberOfClicks)).intValue();
    }
    
    public int getNumberOfUniques() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getNumberOfUniques)).intValue();
    }

    public int getNumberOfBouncesByTime() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getNumberOfBouncesByTime)).intValue();
    }
    
    public int getNumberOfBouncesByPage() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getNumberOfBouncesByPage)).intValue();
    }

    public Integer getnumberOfCouncesByPage() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getNumberOfBouncesByPage)).intValue();
    }
    
    public Integer getNumberOfConversions() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getNumberOfConversions)).intValue();
    }
    //TODO?
    public Double getTotalCost() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getTotalCost)).doubleValue();
    }
    //TODO
    public Double getCTR() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getCTR)).doubleValue();
    }
    //TODO
    public Double getCPA() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getCPA)).doubleValue();
    }
    //TODO
    public Double getCPC() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getCPC)).doubleValue();
    }
    //TODO
    public Double getCPM() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getCPM)).doubleValue();
    }
    //TODO
    public Double getBounceRate() {
        return getNumberFirstColumnAndClose(this.dbM.query(QueryComposer.getBounceRate)).doubleValue();
    }


    public Date getStartDate() {
        try {
            ResultSet resultStartDate = this.dbM.query(QueryComposer.getStartDate);
            Date tmp = Stringifiable.secondsToDate(resultStartDate.getLong("d"));
            close(resultStartDate);
            return tmp;
        } catch (Exception e) {
            return new Date();
        }
    }

    public Date getEndDate() {
        try {
            ResultSet resultStartDate = this.dbM.query(QueryComposer.getEndDate);
            Date tmp = Stringifiable.secondsToDate(resultStartDate.getLong("d"));
            close(resultStartDate);
            return tmp;
        } catch (Exception e) {
            return new Date();
        }
    }

}