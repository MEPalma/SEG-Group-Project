package DatabaseManager;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.NumberFormat;
import java.util.*;

/*
 * Created by Marco-Edoardo Palma.
 */
import Commons.*;
import static DatabaseManager.Stringifiable.globalDateFormat;
import java.text.ParseException;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * This class will process queries from QueryComposer.java into DatabaseManager.
 * The 'interface' between frontend and backend
 */
public class DataExchange
{

    private DatabaseManager dbM;

    public DataExchange(DatabaseManager databaseManager)
    {
        this.dbM = databaseManager;
    }

    /**
     * formats the price according to the UK currency.
     *
     * @param price
     * @return
     */
    public static String formatPrice(double price)
    {
        NumberFormat priceNumberFormat = NumberFormat.getCurrencyInstance(Locale.UK);
        return priceNumberFormat.format(price);
    }

    /**
     * formats the percentage to 2dp
     *
     * @param percentage
     * @return
     */
    public static String formatPercentage(double percentage)
    {
        NumberFormat numberFormat = NumberFormat.getPercentInstance();
        numberFormat.setMaximumFractionDigits(2);
        numberFormat.setMinimumFractionDigits(2);
        return numberFormat.format(percentage / 100);
    }

    /**
     * closes the connection of the database. Do this only before exiting the
     * application!
     */
    public void close()
    {
        this.dbM.close();
    }

    /**
     * closes the ResultSet of a query. this should be called at the end of
     * every parsing routine.
     *
     * @param resultSet
     */
    public static void close(ResultSet resultSet)
    {
        try
        {
            resultSet.close();
        } catch (SQLException e)
        {
            e.printStackTrace();
        }
    }

//    public void writeQuery(String q)
//    {
//        this.dbM.writeQuery(q);
//    }
//    public void writeQuery(List<String> list)
//    {
//        this.dbM.writeQuery(list);
//    }
    /**
     * Executes the batch of a Statement, then closes the Statement.
     *
     * @param s
     * @throws SQLException
     */
    public void writeSqlStatement(Statement s) throws SQLException
    {
        s.executeBatch();
        s.close();
    }

    /**
     * Returns a statement generated by the Database connection.
     *
     * @return
     * @throws SQLException
     */
    public Statement getSqlStatement() throws SQLException
    {
        return this.dbM.getDbCon().createStatement();
    }

    /**
     * turns on and off the pragma on foreign keys. This might speed up the
     * insertion process of multiple insert statements. it is important for this
     * to be turned on after the insertion was carried out, in order to ensure
     * the integrity of the data in the database.
     *
     * @param b
     */
    public void setForiegnKeyPragma(boolean b)
    {
        if (b)
        {
            this.dbM.writeQuery("PRAGMA foreign_keys = ON;");
        } else
        {
            this.dbM.writeQuery("PRAGMA foreign_keys = OFF;");
        }
    }

    /**
     * Enables and disables the auto commit function of the connection with the
     * database. When off, no commits will be performed until the commit
     * function is called. Useful when inserting large amount of data, is should
     * be turned on whenever possible.
     *
     * @param b
     * @throws SQLException
     */
    public void setAutoCommit(boolean b) throws SQLException
    {
        this.dbM.getDbCon().setAutoCommit(b);
    }

    /**
     * Commits immediately pending statements on the database connection.
     *
     * @throws SQLException
     */
    public void commitNow() throws SQLException
    {
        this.dbM.getDbCon().commit();
    }

    /**
     * returns the last id generated by the database. This is especially useful
     * when after insert statement with a auto increment id.
     *
     * @return
     */
    private int getLastID()
    {
        try
        {
            ResultSet resultSet = this.dbM.query(QueryComposer.GETLASTID);
            int c = resultSet.getInt("id");
            close(resultSet);
            return c;
        } catch (SQLException e)
        {
            e.printStackTrace();
        }
        System.exit(8);
        return -1;
    }

    /*
        PARSERS:
    
            SINGLE RETURNS (parse only one object from a ResultSet)
     */
    /**
     * Parses a ResultSet into a UserEntry and does not close the ResultSet.
     * returns null if a parsing error occurred.
     *
     * @param rset
     * @return
     */
    private UserEntry parseUserEntry(ResultSet rset)
    {
        try
        {
            return new UserEntry(
                    rset.getString("id"),
                    UserEntry.Gender.valueOf(rset.getString("gender")),
                    UserEntry.Age.valueOf(rset.getString("age")),
                    UserEntry.Income.valueOf(rset.getString("income")));
        } catch (SQLException ex)
        {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * Parses a ResultSet into a ImpressionEntry and does not close the
     * ResultSet. returns null if a parsing error occurred.
     *
     * @param rset
     * @return
     */
    private ImpressionEntry parseImpressionEntry(ResultSet rset)
    {
        try
        {
            return new ImpressionEntry(
                    rset.getInt("id"),
                    rset.getString("userId"),
                    globalDateFormat.parse(rset.getString("date")),
                    ImpressionEntry.Context.valueOf(rset.getString("context")),
                    rset.getDouble("impressionCost"));
        } catch (SQLException ex)
        {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ParseException ex)
        {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * Parses a ResultSet into a ClickEntry and does not close the ResultSet.
     * returns null if a parsing error occurred.
     *
     * @param rset
     * @return
     */
    private ClickEntry parseClickEntry(ResultSet rset)
    {
        try
        {
            return new ClickEntry(
                    rset.getInt("id"),
                    rset.getString("userId"),
                    globalDateFormat.parse(rset.getString("date")),
                    rset.getDouble("clickCost"));
        } catch (SQLException | ParseException ex)
        {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * Parses a ResultSet into a ServerEntry and does not close the ResultSet.
     * returns null if a parsing error occurred.
     *
     * @param rset
     * @return
     */
    private ServerEntry parseServerEntry(ResultSet rset)
    {
        try
        {
            return new ServerEntry(
                    rset.getInt("id"),
                    rset.getString("userId"),
                    globalDateFormat.parse(rset.getString("entryDate")),
                    globalDateFormat.parse(rset.getString("exitDate")),
                    rset.getInt("pagesViewed"),
                    ServerEntry.Conversion.valueOf(rset.getString("conversion")));
        } catch (SQLException | ParseException ex)
        {
            Logger.getLogger(DataExchange.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /*
            MULTIPLE RETURNS (parse a list of objects from a ResultSet)
     */
    /**
     * Parses a result set into a list of UserEntrys, returns an empty list if a
     * parsing error occurred. It does not close the ResultSet.
     *
     * @param rset
     * @return
     */
    private List<UserEntry> parseUserEntrys(ResultSet rset)
    {
        try
        {
            List<UserEntry> users = new LinkedList<UserEntry>();
            while (rset.next())
            {
                users.add(parseUserEntry(rset));
            }

            return users;
        } catch (Exception e)
        {
            e.printStackTrace();
            return new LinkedList<UserEntry>();
        }
    }

    /**
     * Parses a result set into a list of ImpressionEntry, returns an empty list
     * if a parsing error occurred. It does not close the ResultSet.
     *
     * @param rset
     * @return
     */
    private List<ImpressionEntry> parseImpressionEntrys(ResultSet rset)
    {
        try
        {
            List<ImpressionEntry> impressions = new LinkedList<ImpressionEntry>();
            while (rset.next())
            {
                impressions.add(parseImpressionEntry(rset));
            }

            return impressions;
        } catch (Exception e)
        {
            e.printStackTrace();
            return new LinkedList<ImpressionEntry>();
        }
    }

    /**
     * Parses a result set into a list of ClickEntry, returns an empty list if a
     * parsing error occurred. It does not close the ResultSet.
     *
     * @param rset
     * @return
     */
    private List<ClickEntry> parseClickEntrys(ResultSet rset)
    {
        try
        {
            List<ClickEntry> clicks = new LinkedList<ClickEntry>();
            while (rset.next())
            {
                clicks.add(parseClickEntry(rset));
            }

            return clicks;
        } catch (SQLException e)
        {
            return new LinkedList<ClickEntry>();
        }
    }

    /**
     * Parses a result set into a list of ServerEntry, returns an empty list if
     * a parsing error occurred. It does not close the ResultSet.
     *
     * @param rset
     * @return
     */
    private List<ServerEntry> parseServerEntrys(ResultSet rset)
    {
        try
        {
            List<ServerEntry> servers = new LinkedList<ServerEntry>();
            while (rset.next())
            {
                servers.add(parseServerEntry(rset));
            }

            return servers;
        } catch (Exception e)
        {
            e.printStackTrace();
            return new LinkedList<ServerEntry>();
        }
    }

    /**
     * Parses a result set into a map of settings in the form name -> value,
     * returns an empty map if a parsing error occurred. It does not close the
     * ResultSet.
     *
     * @param rset
     * @return
     */
    private Map<String, String> parseSettings(ResultSet rset)
    {
        try
        {
            Map<String, String> settings = new HashMap<String, String>();
            while (rset.next())
            {
                settings.put(rset.getString("name"), rset.getString("value"));
            }

            return settings;
        } catch (Exception e)
        {
            e.printStackTrace();
            return new HashMap<String, String>();
        }
    }

    /*
        INSERT STATEMENTS
     */
    public void insertUserStmt(UserEntry user)
    {
        this.dbM.writeQuery(QueryComposer.insertUserStmt(user));
    }

    public void insertImpressionStmt(ImpressionEntry ie)
    {
        this.dbM.writeQuery(QueryComposer.insertImpressionStmt(ie));
        ie.setId(this.getLastID());
    }

    public void insertClickStmt(ClickEntry ce)
    {
        this.dbM.writeQuery(QueryComposer.insertClickStmt(ce));
        ce.setId(this.getLastID());
    }

    public void insertServerStmt(ServerEntry se)
    {
        this.dbM.writeQuery(QueryComposer.insertServerStmt(se));
        se.setId(this.getLastID());
    }

    public void insertSettingStmt(String name, String value)
    {
        this.dbM.writeQuery(QueryComposer.insertSettingStmt(name, value));
    }

    /*
        UPDATE STATEMENTS
     */
    // if you need them call me up (Marco)
    /*
        DELETE STATEMENTS
     */
    // if you need them call me up (Marco)
    /*
        DROP ALL STATEMENTS
     */
    public void dropAllFrom_USERS()
    {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_USERS);
    }

    public void dropAllFrom_IMPRESSION_LOGS()
    {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_IMPRESSION_LOGS);
    }

    public void dropAllFrom_CLICK_LOGS()
    {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_CLICK_LOGS);
    }

    public void dropAllFrom_SERVER_LOGS()
    {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_SERVER_LOGS);
    }

    public void dropAllFrom_SETTINGS()
    {
        this.dbM.writeQuery(QueryComposer.dropAllFrom_SETTINGS);
    }

    public void dropAll_noSettings()
    {
        this.dbM.writeQuery(QueryComposer.dropAll_noSettings);
    }

    /*
        COUNT STATEMENTS
     */
    
    private int parseCountQuery(ResultSet resultSet)
    {
        try
        {
            int tmp = resultSet.getInt("c");
            close(resultSet);
            return tmp;
        } catch (SQLException e)
        {
            e.printStackTrace();
            return 0;
        }
    }
    
    public int countAllFrom_USERS()
    {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_USERS));
    }
    
    public int countAllFrom_IMPRESSION_LOGS()
    {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_IMPRESSION_LOGS));
    }
    
    public int countAllFrom_CLICK_LOGS()
    {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_CLICK_LOGS));
    }
    
    public int countAllFrom_SERVER_LOGS()
    {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_SERVER_LOGS));
    }
    
    public int countAllFrom_SETTINGS()
    {
        return this.parseCountQuery(this.dbM.query(QueryComposer.countAllFrom_SETTINGS));
    }

    /*
        SELECT ALL STATEMENTS
     */
    public List<UserEntry> selectAllFrom_USERS()
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_USERS);
        List tmp = parseUserEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ImpressionEntry> selectAllFrom_IMPRESSION_LOGS()
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_IMPRESSION_LOGS);
        List tmp = parseImpressionEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ClickEntry> selectAllFrom_CLICK_LOGS()
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_CLICK_LOGS);
        List tmp = parseClickEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ServerEntry> selectAllFrom_SERVER_LOGS()
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_SERVER_LOGS);
        List tmp = parseServerEntrys(rset);
        close(rset);
        return tmp;
    }

    public Map<String, String> selectAllFrom_SETTINGS()
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectAllFrom_SETTINGS);
        Map tmp = parseSettings(rset);
        close(rset);
        return tmp;
    }

    /*
        SELECT BY ID
     */
    public UserEntry selectByIdFrom_USERS(String id)
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectByIdFrom_USERS(id));

        UserEntry tmp = (UserEntry) this.parseUserEntry(rset);

        close(rset);
        return tmp;
    }

    public ImpressionEntry selectByIdFrom_IMPRESSION_LOGS(int id)
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectByIdFrom_IMPRESSION_LOGS(id));

        ImpressionEntry tmp = (ImpressionEntry) this.parseImpressionEntry(rset);

        close(rset);
        return tmp;
    }

    public ClickEntry selectByIdFrom_CLICK_LOGS(int id)
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectByIdFrom_CLICK_LOGS(id));

        ClickEntry tmp = (ClickEntry) this.parseClickEntry(rset);

        close(rset);
        return tmp;
    }

    public ServerEntry selectByIdFrom_SERVER_LOGS(int id)
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectByIdFrom_SERVER_LOGS(id));

        ServerEntry tmp = (ServerEntry) this.parseServerEntry(rset);

        close(rset);
        return tmp;
    }

    /*
        SELECT BY userId
     */
    public List<ImpressionEntry> selectByUserIdFrom_IMPRESSION_LOGS(String userId)
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectByUserIdFrom_IMPRESSION_LOGS(userId));
        List tmp = parseImpressionEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ClickEntry> selectByUserIdFrom_CLICK_LOGS(String userId)
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectByUserIdFrom_CLICK_LOGS(userId));
        List tmp = parseClickEntrys(rset);
        close(rset);
        return tmp;
    }

    public List<ServerEntry> selectByUserIdFrom_SERVER_LOGS(String userId)
    {
        ResultSet rset = this.dbM.query(QueryComposer.selectByUserIdFrom_SERVER_LOGS(userId));
        List tmp = parseServerEntrys(rset);
        close(rset);
        return tmp;
    }

    public String selectByNameFrom_SETTINGS(String name)
    {
        ResultSet resultSet = this.dbM.query(QueryComposer.selectByNameFrom_SETTINGS(name));
        try
        {
            return resultSet.getString("value");
        } catch (SQLException ex)
        {
            return null;
        }
    }
}
